{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "map",
	"title": "Map",
	"type": "registry:ui",
	"description": "A MapLibre-powered map component with markers, popups, tooltips, routes, and controls.",
	"dependencies": ["maplibre-gl"],
	"devDependencies": ["@lucide/svelte@^0.564.0"],
	"meta": {
		"author": "MariusLang"
	},
	"css": {
		"@layer base": {
			".maplibregl-popup-content": {
				"@apply bg-transparent! shadow-none! p-0! rounded-none!": {}
			},
			".maplibregl-popup-tip": {
				"@apply hidden!": {}
			}
		}
	},
	"files": [
		{
			"content": "<script lang=\"ts\">\n\timport { onMount, onDestroy, setContext, untrack } from \"svelte\";\n\timport MapLibreGL from \"maplibre-gl\";\n\timport \"maplibre-gl/dist/maplibre-gl.css\";\n\timport { browser } from \"$app/environment\";\n\timport { theme } from \"$lib/theme\";\n\n\t// Check document class for theme (works with next-themes, etc.)\n\tfunction getDocumentTheme(): \"light\" | \"dark\" | null {\n\t\tif (typeof document === \"undefined\") return null;\n\t\tif (document.documentElement.classList.contains(\"dark\")) return \"dark\";\n\t\tif (document.documentElement.classList.contains(\"light\")) return \"light\";\n\t\treturn null;\n\t}\n\n\t// Get system preference\n\tfunction getSystemTheme(): \"light\" | \"dark\" {\n\t\tif (typeof window === \"undefined\") return \"light\";\n\t\treturn window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n\t}\n\n\tlet tailwindTheme: \"light\" | \"dark\" = $state(\"light\");\n\n\ttype MapStyleOption = string | MapLibreGL.StyleSpecification;\n\n\t/** Map viewport state */\n\texport type MapViewport = {\n\t\t/** Center coordinates [longitude, latitude] */\n\t\tcenter: [number, number];\n\t\t/** Zoom level */\n\t\tzoom: number;\n\t\t/** Bearing (rotation) in degrees */\n\t\tbearing: number;\n\t\t/** Pitch (tilt) in degrees */\n\t\tpitch: number;\n\t};\n\n\tinterface Props {\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tstyles?: {\n\t\t\tlight?: MapStyleOption;\n\t\t\tdark?: MapStyleOption;\n\t\t};\n\t\ttheme?: \"light\" | \"dark\";\n\t\t/** Map projection type. Use `{ type: \"globe\" }` for 3D globe view. */\n\t\tprojection?: MapLibreGL.ProjectionSpecification;\n\t\tcenter?: [number, number];\n\t\tzoom?: number;\n\t\toptions?: Omit<MapLibreGL.MapOptions, \"container\" | \"style\">;\n\t\t/**\n\t\t * Controlled viewport. When provided with onViewportChange,\n\t\t * the map becomes controlled and viewport is driven by this prop.\n\t\t */\n\t\tviewport?: Partial<MapViewport>;\n\t\t/**\n\t\t * Callback fired continuously as the viewport changes (pan, zoom, rotate, pitch).\n\t\t * Can be used standalone to observe changes, or with `viewport` prop\n\t\t * to enable controlled mode where the map viewport is driven by your state.\n\t\t */\n\t\tonviewportchange?: (viewport: MapViewport) => void;\n\t}\n\n\tconst defaultStyles = {\n\t\tdark: \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n\t\tlight: \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n\t};\n\n\tlet {\n\t\tchildren,\n\t\tstyles,\n\t\ttheme: _theme = \"light\",\n\t\tprojection,\n\t\tcenter = [13.405, 52.52],\n\t\tzoom = 0,\n\t\toptions = {},\n\t\tviewport,\n\t\tonviewportchange,\n\t}: Props = $props();\n\n\tlet mapContainer: HTMLDivElement;\n\tlet map: MapLibreGL.Map | null = $state(null);\n\tlet isMounted = $state(false);\n\tlet isLoaded = $state(false);\n\tlet isStyleLoaded = $state(false);\n\tlet isInteracting = $state(false);\n\tlet hasInitiallyLoaded = $state(false);\n\tlet initialStyleApplied = false;\n\tlet initialCenterZoomApplied = false;\n\tlet styleTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\tlet internalUpdate = false;\n\n\tconst isControlled = $derived(viewport !== undefined && onviewportchange !== undefined);\n\n\tfunction getViewport(mapInstance: MapLibreGL.Map): MapViewport {\n\t\tconst c = mapInstance.getCenter();\n\t\treturn {\n\t\t\tcenter: [c.lng, c.lat],\n\t\t\tzoom: mapInstance.getZoom(),\n\t\t\tbearing: mapInstance.getBearing(),\n\t\t\tpitch: mapInstance.getPitch(),\n\t\t};\n\t}\n\n\tconst mapStyles = $derived({\n\t\tdark: styles?.dark ?? defaultStyles.dark,\n\t\tlight: styles?.light ?? defaultStyles.light,\n\t});\n\n\tconst currentStyle = $derived(tailwindTheme === \"light\" ? mapStyles.light : mapStyles.dark);\n\n\tconst isReady = $derived(isMounted && isLoaded && isStyleLoaded);\n\n\tsetContext(\"map\", {\n\t\tgetMap: () => map,\n\t\tisLoaded: () => hasInitiallyLoaded,\n\t\tisStyleReady: () => isReady,\n\t});\n\n\tfunction clearStyleTimeout() {\n\t\tif (styleTimeoutId) {\n\t\t\tclearTimeout(styleTimeoutId);\n\t\t\tstyleTimeoutId = null;\n\t\t}\n\t}\n\n\tonMount(() => {\n\t\tisMounted = true;\n\n\t\t// Subscribe to theme store for instant updates\n\t\tconst themeUnsubscribe = theme.subscribe((value) => {\n\t\t\ttailwindTheme = value;\n\t\t});\n\n\t\t// Clean up theme subscription\n\t\tonDestroy(() => {\n\t\t\tthemeUnsubscribe();\n\t\t});\n\n\t\tif (browser) {\n\t\t\t// Also watch for document class changes (e.g., external theme togglers)\n\t\t\tconst updateTheme = () => {\n\t\t\t\tconst docTheme = getDocumentTheme();\n\t\t\t\t// Only use document theme if set, otherwise fall back to system preference\n\t\t\t\ttailwindTheme = docTheme ?? getSystemTheme();\n\t\t\t};\n\n\t\t\tupdateTheme();\n\n\t\t\tconst observer = new MutationObserver(updateTheme);\n\t\t\tobserver.observe(document.documentElement, {\n\t\t\t\tattributes: true,\n\t\t\t\tattributeFilter: [\"class\"],\n\t\t\t});\n\n\t\t\t// Also watch for system preference changes\n\t\t\tconst mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n\t\t\tconst handleSystemChange = (e: MediaQueryListEvent) => {\n\t\t\t\t// Only use system preference if no document class is set\n\t\t\t\tif (!getDocumentTheme()) {\n\t\t\t\t\ttailwindTheme = e.matches ? \"dark\" : \"light\";\n\t\t\t\t}\n\t\t\t};\n\t\t\tmediaQuery.addEventListener(\"change\", handleSystemChange);\n\n\t\t\tonDestroy(() => {\n\t\t\t\tobserver.disconnect();\n\t\t\t\tmediaQuery.removeEventListener(\"change\", handleSystemChange);\n\t\t\t});\n\t\t}\n\n\t\tconst mapInstance = new MapLibreGL.Map({\n\t\t\tcontainer: mapContainer,\n\t\t\tstyle: currentStyle,\n\t\t\trenderWorldCopies: false,\n\t\t\tattributionControl: {\n\t\t\t\tcompact: true,\n\t\t\t},\n\t\t\tcenter: viewport?.center ?? center,\n\t\t\tzoom: viewport?.zoom ?? zoom,\n\t\t\tbearing: viewport?.bearing ?? 0,\n\t\t\tpitch: viewport?.pitch ?? 0,\n\t\t\t...options,\n\t\t});\n\n\t\tconst styleDataHandler = () => {\n\t\t\tclearStyleTimeout();\n\t\t\t// Delay to ensure style is fully processed before allowing layer operations\n\t\t\t// This is a workaround to avoid race conditions with the style loading\n\t\t\t// else we have to force update every layer on setStyle change\n\t\t\tstyleTimeoutId = setTimeout(() => {\n\t\t\t\tisStyleLoaded = true;\n\t\t\t\tif (!initialStyleApplied) {\n\t\t\t\t\tinitialStyleApplied = true;\n\t\t\t\t}\n\t\t\t\tif (!hasInitiallyLoaded) {\n\t\t\t\t\thasInitiallyLoaded = true;\n\t\t\t\t}\n\t\t\t\tif (projection) {\n\t\t\t\t\tmapInstance.setProjection(projection);\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t};\n\n\t\tconst loadHandler = () => {\n\t\t\tisLoaded = true;\n\t\t};\n\n\t\t// Viewport change handler - skip if triggered by internal update\n\t\tconst handleMove = () => {\n\t\t\tif (internalUpdate) return;\n\t\t\tonviewportchange?.(getViewport(mapInstance));\n\t\t};\n\n\t\tmapInstance.on(\"load\", loadHandler);\n\t\tmapInstance.on(\"styledata\", styleDataHandler);\n\t\tmapInstance.on(\"move\", handleMove);\n\n\t\tmapInstance.on(\"dragstart\", () => (isInteracting = true));\n\t\tmapInstance.on(\"dragend\", () => (isInteracting = false));\n\t\tmapInstance.on(\"zoomstart\", () => (isInteracting = true));\n\t\tmapInstance.on(\"zoomend\", () => (isInteracting = false));\n\t\tmapInstance.on(\"rotatestart\", () => (isInteracting = true));\n\t\tmapInstance.on(\"rotateend\", () => (isInteracting = false));\n\t\tmapInstance.on(\"pitchstart\", () => (isInteracting = true));\n\t\tmapInstance.on(\"pitchend\", () => (isInteracting = false));\n\n\t\tmap = mapInstance;\n\t});\n\n\t// Sync controlled viewport to map\n\t$effect(() => {\n\t\tif (!map || !isControlled || !viewport) return;\n\t\tif (map.isMoving()) return;\n\n\t\tconst current = getViewport(map);\n\t\tconst next = {\n\t\t\tcenter: viewport.center ?? current.center,\n\t\t\tzoom: viewport.zoom ?? current.zoom,\n\t\t\tbearing: viewport.bearing ?? current.bearing,\n\t\t\tpitch: viewport.pitch ?? current.pitch,\n\t\t};\n\n\t\tif (\n\t\t\tnext.center[0] === current.center[0] &&\n\t\t\tnext.center[1] === current.center[1] &&\n\t\t\tnext.zoom === current.zoom &&\n\t\t\tnext.bearing === current.bearing &&\n\t\t\tnext.pitch === current.pitch\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tinternalUpdate = true;\n\t\tmap!.once(\"moveend\", () => {\n\t\t\tinternalUpdate = false;\n\t\t});\n\t\tmap.jumpTo(next);\n\t});\n\n\t$effect(() => {\n\t\tconst style = currentStyle;\n\n\t\tif (!map || !initialStyleApplied) {\n\t\t\treturn;\n\t\t}\n\n\t\tuntrack(() => {\n\t\t\tconst currCenter = map!.getCenter();\n\t\t\tconst currZoom = map!.getZoom();\n\t\t\tconst currBearing = map!.getBearing();\n\t\t\tconst currPitch = map!.getPitch();\n\n\t\t\tisStyleLoaded = false;\n\t\t\tmap!.setStyle(style, { diff: true });\n\n\t\t\tmap!.once(\"styledata\", () => {\n\t\t\t\tmap!.jumpTo({\n\t\t\t\t\tcenter: currCenter,\n\t\t\t\t\tzoom: currZoom,\n\t\t\t\t\tbearing: currBearing,\n\t\t\t\t\tpitch: currPitch,\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\t$effect(() => {\n\t\tif (!map || !isReady || isInteracting || initialCenterZoomApplied || isControlled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only apply initial center/zoom once, then let user move freely\n\t\t// Skip if controlled mode is enabled\n\t\tinitialCenterZoomApplied = true;\n\n\t\tconst [lng, lat] = center;\n\n\t\tuntrack(() => {\n\t\t\tmap!.easeTo({ center: [lng, lat], zoom });\n\t\t});\n\t});\n\n\tonDestroy(() => {\n\t\tmap?.remove();\n\t\tmap = null;\n\t\tisLoaded = false;\n\t\tisStyleLoaded = false;\n\t});\n</script>\n\n<div bind:this={mapContainer} class=\"relative h-full w-full\">\n\t{#if !isReady}\n\t\t<div class=\"absolute inset-0 flex items-center justify-center\">\n\t\t\t<div class=\"flex gap-1\">\n\t\t\t\t<span class=\"bg-muted-foreground/60 size-1.5 animate-pulse rounded-full\"></span>\n\t\t\t\t<span\n\t\t\t\t\tclass=\"bg-muted-foreground/60 size-1.5 animate-pulse rounded-full [animation-delay:150ms]\"\n\t\t\t\t></span>\n\t\t\t\t<span\n\t\t\t\t\tclass=\"bg-muted-foreground/60 size-1.5 animate-pulse rounded-full [animation-delay:300ms]\"\n\t\t\t\t></span>\n\t\t\t</div>\n\t\t</div>\n\t{/if}\n\t{#if hasInitiallyLoaded}\n\t\t{@render children?.()}\n\t{/if}\n</div>\n",
			"type": "registry:ui",
			"target": "map/Map.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext, setContext, untrack } from \"svelte\";\n\timport MapLibreGL, { type MarkerOptions } from \"maplibre-gl\";\n\n\ttype Anchor =\n\t\t| \"center\"\n\t\t| \"top\"\n\t\t| \"bottom\"\n\t\t| \"left\"\n\t\t| \"right\"\n\t\t| \"top-left\"\n\t\t| \"top-right\"\n\t\t| \"bottom-left\"\n\t\t| \"bottom-right\";\n\n\tinterface Props {\n\t\tlongitude: number;\n\t\tlatitude: number;\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tonclick?: (e: MouseEvent) => void;\n\t\tonmouseenter?: (e: MouseEvent) => void;\n\t\tonmouseleave?: (e: MouseEvent) => void;\n\t\tondragstart?: (lngLat: { lng: number; lat: number }) => void;\n\t\tondrag?: (lngLat: { lng: number; lat: number }) => void;\n\t\tondragend?: (lngLat: { lng: number; lat: number }) => void;\n\t\tdraggable?: boolean;\n\t\tanchor?: Anchor;\n\t\toffset?: MarkerOptions[\"offset\"];\n\t\trotation?: number;\n\t\tpitchAlignment?: MarkerOptions[\"pitchAlignment\"];\n\t\trotationAlignment?: MarkerOptions[\"rotationAlignment\"];\n\t}\n\n\tlet {\n\t\tlongitude,\n\t\tlatitude,\n\t\tchildren,\n\t\tonclick,\n\t\tonmouseenter,\n\t\tonmouseleave,\n\t\tondragstart,\n\t\tondrag,\n\t\tondragend,\n\t\tdraggable = false,\n\t\tanchor = \"center\",\n\t\toffset,\n\t\trotation,\n\t\tpitchAlignment,\n\t\trotationAlignment,\n\t}: Props = $props();\n\n\tconst mapCtx = getContext<{\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisLoaded: () => boolean;\n\t}>(\"map\");\n\n\tlet marker: MapLibreGL.Marker | null = $state(null);\n\tlet markerElement: HTMLDivElement | null = $state(null);\n\tlet isReady = $state(false);\n\tlet isDragging = $state(false);\n\n\t// Provide marker context for child components\n\tsetContext(\"marker\", {\n\t\tgetMarker: () => marker,\n\t\tgetElement: () => markerElement,\n\t\tgetMap: () => mapCtx.getMap(),\n\t\tisReady: () => isReady,\n\t\tisDraggable: () => draggable,\n\t\tisDragging: () => isDragging,\n\t});\n\n\t// Create marker when map is ready\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst mapLoaded = mapCtx.isLoaded();\n\n\t\tif (!map || !mapLoaded) return;\n\n\t\t// Validate coordinates (untracked â€” position updates are handled by a separate effect)\n\t\tconst lng = untrack(() => longitude);\n\t\tconst lat = untrack(() => latitude);\n\t\tif (\n\t\t\ttypeof lng !== \"number\" ||\n\t\t\ttypeof lat !== \"number\" ||\n\t\t\tNumber.isNaN(lng) ||\n\t\t\tNumber.isNaN(lat)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create container element programmatically\n\t\tconst container = document.createElement(\"div\");\n\t\tcontainer.className = \"cursor-pointer\";\n\t\tmarkerElement = container;\n\n\t\t// Build marker options\n\t\tconst markerOptions: MarkerOptions = {\n\t\t\telement: container,\n\t\t\tdraggable,\n\t\t\tanchor,\n\t\t};\n\n\t\tif (offset !== undefined) markerOptions.offset = offset;\n\t\tif (rotation !== undefined) markerOptions.rotation = rotation;\n\t\tif (pitchAlignment !== undefined) markerOptions.pitchAlignment = pitchAlignment;\n\t\tif (rotationAlignment !== undefined) markerOptions.rotationAlignment = rotationAlignment;\n\n\t\t// Create and add marker\n\t\tconst markerInstance = new MapLibreGL.Marker(markerOptions).setLngLat([lng, lat]).addTo(map);\n\n\t\tmarker = markerInstance;\n\n\t\t// Mouse event listeners on the container\n\t\tif (onclick) container.addEventListener(\"click\", onclick);\n\t\tif (onmouseenter) container.addEventListener(\"mouseenter\", onmouseenter);\n\t\tif (onmouseleave) {\n\t\t\tcontainer.addEventListener(\"mouseleave\", (e) => {\n\t\t\t\tif (!isDragging) onmouseleave(e);\n\t\t\t});\n\t\t}\n\n\t\t// Drag event handlers\n\t\tconst handleDragStart = () => {\n\t\t\tisDragging = true;\n\t\t\tconst lngLat = markerInstance.getLngLat();\n\t\t\tondragstart?.({ lng: lngLat.lng, lat: lngLat.lat });\n\t\t};\n\t\tconst handleDrag = () => {\n\t\t\tconst lngLat = markerInstance.getLngLat();\n\t\t\tondrag?.({ lng: lngLat.lng, lat: lngLat.lat });\n\t\t};\n\t\tconst handleDragEnd = () => {\n\t\t\tisDragging = false;\n\t\t\tconst lngLat = markerInstance.getLngLat();\n\t\t\tondragend?.({ lng: lngLat.lng, lat: lngLat.lat });\n\t\t};\n\n\t\tif (draggable) {\n\t\t\tmarkerInstance.on(\"dragstart\", handleDragStart);\n\t\t\tmarkerInstance.on(\"drag\", handleDrag);\n\t\t\tmarkerInstance.on(\"dragend\", handleDragEnd);\n\t\t}\n\n\t\tisReady = true;\n\n\t\t// Cleanup\n\t\treturn () => {\n\t\t\tif (onclick) container.removeEventListener(\"click\", onclick);\n\t\t\tif (onmouseenter) container.removeEventListener(\"mouseenter\", onmouseenter);\n\t\t\tif (onmouseleave) container.removeEventListener(\"mouseleave\", onmouseleave);\n\n\t\t\tif (draggable) {\n\t\t\t\tmarkerInstance.off(\"dragstart\", handleDragStart);\n\t\t\t\tmarkerInstance.off(\"drag\", handleDrag);\n\t\t\t\tmarkerInstance.off(\"dragend\", handleDragEnd);\n\t\t\t}\n\n\t\t\tmarkerInstance.remove();\n\t\t\tmarker = null;\n\t\t\tmarkerElement = null;\n\t\t\tisReady = false;\n\t\t};\n\t});\n\n\t// Update position when coordinates change\n\t$effect(() => {\n\t\tif (\n\t\t\tmarker &&\n\t\t\ttypeof longitude === \"number\" &&\n\t\t\ttypeof latitude === \"number\" &&\n\t\t\t!Number.isNaN(longitude) &&\n\t\t\t!Number.isNaN(latitude)\n\t\t) {\n\t\t\tmarker.setLngLat([longitude, latitude]);\n\t\t}\n\t});\n\n\t// Update draggable when prop changes\n\t$effect(() => {\n\t\tmarker?.setDraggable(draggable);\n\t});\n</script>\n\n<!-- Children are MarkerContent, MarkerPopup, MarkerTooltip -->\n{@render children?.()}\n",
			"type": "registry:ui",
			"target": "map/MapMarker.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL from \"maplibre-gl\";\n\timport { cn } from \"$UTILS$.js\";\n\n\tinterface Props {\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tclass?: string;\n\t}\n\n\tlet { children, class: className }: Props = $props();\n\n\tconst markerCtx = getContext<{\n\t\tgetMarker: () => MapLibreGL.Marker | null;\n\t\tgetElement: () => HTMLDivElement | null;\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisReady: () => boolean;\n\t}>(\"marker\");\n\n\tlet wrapperElement: HTMLDivElement | null = $state(null);\n\tlet movedContent: Node[] = [];\n\n\t// Move content to marker element when ready\n\t$effect(() => {\n\t\tconst element = markerCtx.getElement();\n\t\tconst ready = markerCtx.isReady();\n\n\t\tif (!ready || !element || !wrapperElement) return;\n\n\t\t// Store and move children to marker element\n\t\tmovedContent = Array.from(wrapperElement.childNodes);\n\t\tmovedContent.forEach((child) => element.appendChild(child));\n\n\t\treturn () => {\n\t\t\t// Move content back on cleanup\n\t\t\tmovedContent.forEach((child) => {\n\t\t\t\tif (wrapperElement && child.parentNode === element) {\n\t\t\t\t\twrapperElement.appendChild(child);\n\t\t\t\t}\n\t\t\t});\n\t\t\tmovedContent = [];\n\t\t};\n\t});\n</script>\n\n<!-- Hidden wrapper that holds content until marker is ready -->\n<div bind:this={wrapperElement} style=\"display: contents;\">\n\t<div class={cn(\"relative cursor-pointer\", className)}>\n\t\t{#if children}\n\t\t\t{@render children()}\n\t\t{:else}\n\t\t\t<!-- Default marker icon -->\n\t\t\t<div class=\"relative h-4 w-4 rounded-full border-2 border-white bg-blue-500 shadow-lg\"></div>\n\t\t{/if}\n\t</div>\n</div>\n",
			"type": "registry:ui",
			"target": "map/MarkerContent.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL, { type PopupOptions } from \"maplibre-gl\";\n\timport { cn } from \"$UTILS$.js\";\n\timport X from \"@lucide/svelte/icons/x\";\n\n\tinterface Props {\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tclass?: string;\n\t\tcloseButton?: boolean;\n\t\toffset?: PopupOptions[\"offset\"];\n\t\tanchor?: PopupOptions[\"anchor\"];\n\t\tcloseOnClick?: boolean;\n\t\tcloseOnMove?: boolean;\n\t\tfocusAfterOpen?: boolean;\n\t\tmaxWidth?: string;\n\t}\n\n\tlet {\n\t\tchildren,\n\t\tclass: className,\n\t\tcloseButton = false,\n\t\toffset = 16,\n\t\tanchor,\n\t\tcloseOnClick,\n\t\tcloseOnMove,\n\t\tfocusAfterOpen,\n\t\tmaxWidth,\n\t}: Props = $props();\n\n\tconst markerCtx = getContext<{\n\t\tgetMarker: () => MapLibreGL.Marker | null;\n\t\tgetElement: () => HTMLDivElement | null;\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisReady: () => boolean;\n\t\tisDraggable?: () => boolean;\n\t\tisDragging?: () => boolean;\n\t}>(\"marker\");\n\n\tlet popup: MapLibreGL.Popup | null = null;\n\tlet wrapperElement: HTMLDivElement | null = $state(null);\n\tlet shouldStayOpen = $state(false);\n\n\t// Create popup when marker is ready\n\t$effect(() => {\n\t\tconst marker = markerCtx.getMarker();\n\t\tconst ready = markerCtx.isReady();\n\n\t\tif (!ready || !marker || !wrapperElement) return;\n\n\t\t// Create popup container\n\t\tconst container = document.createElement(\"div\");\n\n\t\t// Build popup options\n\t\tconst popupOptions: PopupOptions = {\n\t\t\toffset,\n\t\t\tcloseButton: false,\n\t\t\tclassName: \"maplibre-popup-transparent\",\n\t\t};\n\n\t\tif (anchor !== undefined) popupOptions.anchor = anchor;\n\t\tif (closeOnClick !== undefined) popupOptions.closeOnClick = closeOnClick;\n\t\tif (closeOnMove !== undefined) popupOptions.closeOnMove = closeOnMove;\n\t\tif (focusAfterOpen !== undefined) popupOptions.focusAfterOpen = focusAfterOpen;\n\n\t\t// If marker is draggable, preserve popup state during movement\n\t\tif (markerCtx.isDraggable?.()) {\n\t\t\tpopupOptions.closeOnMove = false;\n\t\t}\n\n\t\t// Create popup\n\t\tconst popupInstance = new MapLibreGL.Popup(popupOptions).setDOMContent(container);\n\n\t\tif (maxWidth) {\n\t\t\tpopupInstance.setMaxWidth(maxWidth);\n\t\t} else {\n\t\t\tpopupInstance.setMaxWidth(\"none\");\n\t\t}\n\n\t\t// Attach popup to marker\n\t\tmarker.setPopup(popupInstance);\n\t\tpopup = popupInstance;\n\n\t\t// Prevent popup from closing during drag\n\t\t$effect(() => {\n\t\t\tconst isDragging = markerCtx.isDragging?.();\n\t\t\tif (isDragging && popupInstance.isOpen()) {\n\t\t\t\tshouldStayOpen = true;\n\t\t\t}\n\t\t});\n\n\t\t// Reopen popup after drag if it was open\n\t\t$effect(() => {\n\t\t\tconst isDragging = markerCtx.isDragging?.();\n\t\t\tif (!isDragging && shouldStayOpen && !popupInstance.isOpen()) {\n\t\t\t\t// Small delay to ensure popup has finished closing\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (!popupInstance.isOpen()) {\n\t\t\t\t\t\tmarker.togglePopup();\n\t\t\t\t\t}\n\t\t\t\t\tshouldStayOpen = false;\n\t\t\t\t}, 10);\n\t\t\t}\n\t\t});\n\n\t\t// Move content to popup container\n\t\twhile (wrapperElement.firstChild) {\n\t\t\tcontainer.appendChild(wrapperElement.firstChild);\n\t\t}\n\n\t\treturn () => {\n\t\t\t// Move content back\n\t\t\twhile (container.firstChild) {\n\t\t\t\twrapperElement?.appendChild(container.firstChild);\n\t\t\t}\n\n\t\t\tpopupInstance.remove();\n\t\t\tpopup = null;\n\t\t};\n\t});\n\n\tfunction handleClose() {\n\t\tpopup?.remove();\n\t}\n</script>\n\n<div bind:this={wrapperElement} style=\"display: contents;\">\n\t<div\n\t\tclass={cn(\n\t\t\t\"animate-in fade-in-0 zoom-in-95 bg-popover text-popover-foreground relative rounded-md border p-3 shadow-md\",\n\t\t\tclassName\n\t\t)}\n\t>\n\t\t{#if closeButton}\n\t\t\t<button\n\t\t\t\ttype=\"button\"\n\t\t\t\tonclick={handleClose}\n\t\t\t\tclass=\"ring-offset-background focus:ring-ring absolute top-1 right-1 z-10 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-none\"\n\t\t\t\taria-label=\"Close popup\"\n\t\t\t>\n\t\t\t\t<X class=\"h-4 w-4\" />\n\t\t\t\t<span class=\"sr-only\">Close</span>\n\t\t\t</button>\n\t\t{/if}\n\t\t{@render children?.()}\n\t</div>\n</div>\n\n<style>\n\t:global(.maplibre-popup-transparent .maplibregl-popup-content) {\n\t\tbackground: transparent;\n\t\tbox-shadow: none;\n\t\tpadding: 0;\n\t}\n\n\t:global(.maplibre-popup-transparent .maplibregl-popup-tip) {\n\t\tdisplay: none;\n\t}\n</style>\n",
			"type": "registry:ui",
			"target": "map/MarkerPopup.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL, { type PopupOptions } from \"maplibre-gl\";\n\timport { cn } from \"$UTILS$.js\";\n\n\tinterface Props {\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tclass?: string;\n\t\toffset?: PopupOptions[\"offset\"];\n\t\tanchor?: PopupOptions[\"anchor\"];\n\t}\n\n\tlet { children, class: className, offset = 16, anchor }: Props = $props();\n\n\tconst markerCtx = getContext<{\n\t\tgetMarker: () => MapLibreGL.Marker | null;\n\t\tgetElement: () => HTMLDivElement | null;\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisReady: () => boolean;\n\t}>(\"marker\");\n\n\tlet wrapperElement: HTMLDivElement | null = $state(null);\n\n\t// Create tooltip popup when marker is ready\n\t$effect(() => {\n\t\tconst marker = markerCtx.getMarker();\n\t\tconst markerElement = markerCtx.getElement();\n\t\tconst map = markerCtx.getMap();\n\t\tconst ready = markerCtx.isReady();\n\n\t\tif (!ready || !marker || !markerElement || !map || !wrapperElement) return;\n\n\t\t// Create popup container\n\t\tconst container = document.createElement(\"div\");\n\n\t\t// Build popup options\n\t\tconst popupOptions: PopupOptions = {\n\t\t\toffset,\n\t\t\tcloseOnClick: true,\n\t\t\tcloseButton: false,\n\t\t\tclassName: \"maplibre-popup-transparent\",\n\t\t};\n\n\t\tif (anchor !== undefined) popupOptions.anchor = anchor;\n\n\t\t// Create popup\n\t\tconst popupInstance = new MapLibreGL.Popup(popupOptions)\n\t\t\t.setMaxWidth(\"none\")\n\t\t\t.setDOMContent(container);\n\n\t\t// Move content to popup container\n\t\twhile (wrapperElement.firstChild) {\n\t\t\tcontainer.appendChild(wrapperElement.firstChild);\n\t\t}\n\n\t\t// Show on hover\n\t\tconst handleMouseEnter = () => {\n\t\t\tpopupInstance.setLngLat(marker.getLngLat()).addTo(map);\n\t\t};\n\n\t\tconst handleMouseLeave = () => {\n\t\t\tpopupInstance.remove();\n\t\t};\n\n\t\tmarkerElement.addEventListener(\"mouseenter\", handleMouseEnter);\n\t\tmarkerElement.addEventListener(\"mouseleave\", handleMouseLeave);\n\n\t\treturn () => {\n\t\t\tmarkerElement.removeEventListener(\"mouseenter\", handleMouseEnter);\n\t\t\tmarkerElement.removeEventListener(\"mouseleave\", handleMouseLeave);\n\n\t\t\t// Move content back\n\t\t\twhile (container.firstChild) {\n\t\t\t\twrapperElement?.appendChild(container.firstChild);\n\t\t\t}\n\n\t\t\tpopupInstance.remove();\n\t\t};\n\t});\n</script>\n\n<div bind:this={wrapperElement} style=\"display: contents;\">\n\t<div\n\t\tclass={cn(\n\t\t\t\"animate-in fade-in-0 zoom-in-95 bg-foreground text-background rounded-md px-2 py-1 text-xs shadow-md\",\n\t\t\tclassName\n\t\t)}\n\t>\n\t\t{@render children?.()}\n\t</div>\n</div>\n\n<style>\n\t:global(.maplibre-popup-transparent .maplibregl-popup-content) {\n\t\tbackground: transparent;\n\t\tbox-shadow: none;\n\t\tpadding: 0;\n\t}\n\n\t:global(.maplibre-popup-transparent .maplibregl-popup-tip) {\n\t\tdisplay: none;\n\t}\n</style>\n",
			"type": "registry:ui",
			"target": "map/MarkerTooltip.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { cn } from \"$UTILS$.js\";\n\n\tinterface Props {\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tclass?: string;\n\t\tposition?: \"top\" | \"bottom\";\n\t}\n\n\tlet { children, class: className, position = \"top\" }: Props = $props();\n\n\tconst positionClasses = {\n\t\ttop: \"bottom-full mb-1\",\n\t\tbottom: \"top-full mt-1\",\n\t};\n</script>\n\n<div\n\tclass={cn(\n\t\t\"absolute left-1/2 -translate-x-1/2 whitespace-nowrap\",\n\t\t\"text-foreground text-[10px] font-medium\",\n\t\tpositionClasses[position],\n\t\tclassName\n\t)}\n>\n\t{@render children?.()}\n</div>\n",
			"type": "registry:ui",
			"target": "map/MarkerLabel.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL, { type PopupOptions } from \"maplibre-gl\";\n\timport { cn } from \"$UTILS$.js\";\n\timport X from \"@lucide/svelte/icons/x\";\n\n\tinterface Props {\n\t\tlongitude: number;\n\t\tlatitude: number;\n\t\tchildren?: import(\"svelte\").Snippet;\n\t\tclass?: string;\n\t\tcloseButton?: boolean;\n\t\tonclose?: () => void;\n\t\toffset?: PopupOptions[\"offset\"];\n\t\tanchor?: PopupOptions[\"anchor\"];\n\t\tcloseOnClick?: boolean;\n\t\tcloseOnMove?: boolean;\n\t\tfocusAfterOpen?: boolean;\n\t\tmaxWidth?: string;\n\t}\n\n\tlet {\n\t\tlongitude,\n\t\tlatitude,\n\t\tchildren,\n\t\tclass: className,\n\t\tcloseButton = false,\n\t\tonclose,\n\t\toffset = 16,\n\t\tanchor,\n\t\tcloseOnClick,\n\t\tcloseOnMove,\n\t\tfocusAfterOpen,\n\t\tmaxWidth,\n\t}: Props = $props();\n\n\tconst mapCtx = getContext<{\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisLoaded: () => boolean;\n\t}>(\"map\");\n\n\tconst markerCtx =\n\t\tgetContext<{\n\t\t\tisDraggable?: () => boolean;\n\t\t}>(\"marker\") || {};\n\n\tlet popup: MapLibreGL.Popup | null = null;\n\tlet wrapperElement: HTMLDivElement | null = $state(null);\n\n\t// Create popup when map is ready\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isLoaded();\n\n\t\tif (!loaded || !map || !wrapperElement) return;\n\n\t\t// Validate coordinates\n\t\tif (\n\t\t\ttypeof longitude !== \"number\" ||\n\t\t\ttypeof latitude !== \"number\" ||\n\t\t\tNumber.isNaN(longitude) ||\n\t\t\tNumber.isNaN(latitude)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create popup container\n\t\tconst container = document.createElement(\"div\");\n\n\t\t// Build popup options\n\t\tconst popupOptions: PopupOptions = {\n\t\t\toffset,\n\t\t\tcloseButton: false,\n\t\t\tclassName: \"maplibre-popup-transparent\",\n\t\t};\n\n\t\t// If marker is draggable, preserve popup state during movement\n\t\tif (markerCtx.isDraggable?.()) {\n\t\t\tpopupOptions.closeOnMove = false;\n\t\t}\n\n\t\tif (anchor !== undefined) popupOptions.anchor = anchor;\n\t\tif (closeOnClick !== undefined) popupOptions.closeOnClick = closeOnClick;\n\t\tif (closeOnMove !== undefined) popupOptions.closeOnMove = closeOnMove;\n\t\tif (focusAfterOpen !== undefined) popupOptions.focusAfterOpen = focusAfterOpen;\n\n\t\t// Create popup\n\t\tconst popupInstance = new MapLibreGL.Popup(popupOptions)\n\t\t\t.setDOMContent(container)\n\t\t\t.setLngLat([longitude, latitude])\n\t\t\t.addTo(map);\n\n\t\tif (maxWidth) {\n\t\t\tpopupInstance.setMaxWidth(maxWidth);\n\t\t} else {\n\t\t\tpopupInstance.setMaxWidth(\"none\");\n\t\t}\n\n\t\tpopup = popupInstance;\n\n\t\t// Handle close event\n\t\tconst handleClose = () => onclose?.();\n\t\tpopupInstance.on(\"close\", handleClose);\n\n\t\t// Move content to popup container\n\t\twhile (wrapperElement.firstChild) {\n\t\t\tcontainer.appendChild(wrapperElement.firstChild);\n\t\t}\n\n\t\treturn () => {\n\t\t\tpopupInstance.off(\"close\", handleClose);\n\n\t\t\t// Move content back\n\t\t\twhile (container.firstChild) {\n\t\t\t\twrapperElement?.appendChild(container.firstChild);\n\t\t\t}\n\n\t\t\tif (popupInstance.isOpen()) {\n\t\t\t\tpopupInstance.remove();\n\t\t\t}\n\t\t\tpopup = null;\n\t\t};\n\t});\n\n\t// Update position when coordinates change\n\t$effect(() => {\n\t\tif (\n\t\t\tpopup &&\n\t\t\ttypeof longitude === \"number\" &&\n\t\t\ttypeof latitude === \"number\" &&\n\t\t\t!Number.isNaN(longitude) &&\n\t\t\t!Number.isNaN(latitude)\n\t\t) {\n\t\t\tpopup.setLngLat([longitude, latitude]);\n\t\t}\n\t});\n\n\tfunction handleClose() {\n\t\tpopup?.remove();\n\t\tonclose?.();\n\t}\n</script>\n\n<div bind:this={wrapperElement} style=\"display: contents;\">\n\t<div\n\t\tclass={cn(\n\t\t\t\"animate-in fade-in-0 zoom-in-95 bg-popover text-popover-foreground relative rounded-md border p-3 shadow-md\",\n\t\t\tclassName\n\t\t)}\n\t>\n\t\t{#if closeButton}\n\t\t\t<button\n\t\t\t\ttype=\"button\"\n\t\t\t\tonclick={handleClose}\n\t\t\t\tclass=\"ring-offset-background focus:ring-ring absolute top-1 right-1 z-10 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-none\"\n\t\t\t\taria-label=\"Close popup\"\n\t\t\t>\n\t\t\t\t<X class=\"h-4 w-4\" />\n\t\t\t\t<span class=\"sr-only\">Close</span>\n\t\t\t</button>\n\t\t{/if}\n\t\t{@render children?.()}\n\t</div>\n</div>\n\n<style>\n\t:global(.maplibre-popup-transparent .maplibregl-popup-content) {\n\t\tbackground: transparent;\n\t\tbox-shadow: none;\n\t\tpadding: 0;\n\t}\n\n\t:global(.maplibre-popup-transparent .maplibregl-popup-tip) {\n\t\tdisplay: none;\n\t}\n</style>\n",
			"type": "registry:ui",
			"target": "map/MapPopup.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL from \"maplibre-gl\";\n\timport { cn } from \"$UTILS$.js\";\n\timport Plus from \"@lucide/svelte/icons/plus\";\n\timport Minus from \"@lucide/svelte/icons/minus\";\n\timport Locate from \"@lucide/svelte/icons/locate\";\n\timport Maximize from \"@lucide/svelte/icons/maximize\";\n\timport Loader2 from \"@lucide/svelte/icons/loader-2\";\n\n\tinterface Props {\n\t\tposition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\";\n\t\tshowZoom?: boolean;\n\t\tshowCompass?: boolean;\n\t\tshowLocate?: boolean;\n\t\tshowFullscreen?: boolean;\n\t\tclass?: string;\n\t\tonlocate?: (coords: { longitude: number; latitude: number }) => void;\n\t}\n\n\tlet {\n\t\tposition = \"bottom-right\",\n\t\tshowZoom = true,\n\t\tshowCompass = false,\n\t\tshowLocate = false,\n\t\tshowFullscreen = false,\n\t\tclass: className,\n\t\tonlocate,\n\t}: Props = $props();\n\n\tconst mapCtx = getContext<{\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisLoaded: () => boolean;\n\t}>(\"map\");\n\n\tlet waitingForLocation = $state(false);\n\tlet compassElement: SVGSVGElement | null = $state(null);\n\tconst loaded = $derived(mapCtx.isLoaded());\n\n\tconst positionClasses = {\n\t\t\"top-left\": \"top-2 left-2\",\n\t\t\"top-right\": \"top-2 right-2\",\n\t\t\"bottom-left\": \"bottom-2 left-2\",\n\t\t\"bottom-right\": \"bottom-10 right-2\",\n\t};\n\n\t// Update compass rotation\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\n\t\tif (!loaded || !map || !compassElement) return;\n\n\t\tconst updateRotation = () => {\n\t\t\tif (!compassElement) return;\n\t\t\tconst bearing = map.getBearing();\n\t\t\tconst pitch = map.getPitch();\n\t\t\tcompassElement.style.transform = `rotateX(${pitch}deg) rotateZ(${-bearing}deg)`;\n\t\t};\n\n\t\tmap.on(\"rotate\", updateRotation);\n\t\tmap.on(\"pitch\", updateRotation);\n\t\tupdateRotation();\n\n\t\treturn () => {\n\t\t\tmap.off(\"rotate\", updateRotation);\n\t\t\tmap.off(\"pitch\", updateRotation);\n\t\t};\n\t});\n\n\tfunction handleZoomIn() {\n\t\tconst map = mapCtx.getMap();\n\t\tmap?.zoomTo(map.getZoom() + 1, { duration: 300 });\n\t}\n\n\tfunction handleZoomOut() {\n\t\tconst map = mapCtx.getMap();\n\t\tmap?.zoomTo(map.getZoom() - 1, { duration: 300 });\n\t}\n\n\tfunction handleResetBearing() {\n\t\tconst map = mapCtx.getMap();\n\t\tmap?.resetNorthPitch({ duration: 300 });\n\t}\n\n\tfunction handleLocate() {\n\t\tconst map = mapCtx.getMap();\n\t\tif (!map) return;\n\n\t\twaitingForLocation = true;\n\n\t\tif (\"geolocation\" in navigator) {\n\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t(position) => {\n\t\t\t\t\tconst coords = {\n\t\t\t\t\t\tlongitude: position.coords.longitude,\n\t\t\t\t\t\tlatitude: position.coords.latitude,\n\t\t\t\t\t};\n\t\t\t\t\tmap.flyTo({\n\t\t\t\t\t\tcenter: [coords.longitude, coords.latitude],\n\t\t\t\t\t\tzoom: 14,\n\t\t\t\t\t\tduration: 1500,\n\t\t\t\t\t});\n\t\t\t\t\tonlocate?.(coords);\n\t\t\t\t\twaitingForLocation = false;\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tconsole.error(\"Error getting location:\", error);\n\t\t\t\t\twaitingForLocation = false;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction handleFullscreen() {\n\t\tconst map = mapCtx.getMap();\n\t\tconst container = map?.getContainer();\n\t\tif (!container) return;\n\n\t\tif (document.fullscreenElement) {\n\t\t\tdocument.exitFullscreen();\n\t\t} else {\n\t\t\tcontainer.requestFullscreen();\n\t\t}\n\t}\n</script>\n\n{#if loaded}\n\t<div class={cn(\"absolute z-10 flex flex-col gap-1.5\", positionClasses[position], className)}>\n\t\t{#if showZoom}\n\t\t\t<div\n\t\t\t\tclass=\"border-border bg-background [&>button:not(:last-child)]:border-border flex flex-col overflow-hidden rounded-md border shadow-sm [&>button:not(:last-child)]:border-b\"\n\t\t\t>\n\t\t\t\t<button\n\t\t\t\t\tonclick={handleZoomIn}\n\t\t\t\t\taria-label=\"Zoom in\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclass=\"hover:bg-accent dark:hover:bg-accent/40 flex size-8 items-center justify-center transition-colors\"\n\t\t\t\t>\n\t\t\t\t\t<Plus class=\"size-4\" />\n\t\t\t\t</button>\n\t\t\t\t<button\n\t\t\t\t\tonclick={handleZoomOut}\n\t\t\t\t\taria-label=\"Zoom out\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclass=\"hover:bg-accent dark:hover:bg-accent/40 flex size-8 items-center justify-center transition-colors\"\n\t\t\t\t>\n\t\t\t\t\t<Minus class=\"size-4\" />\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t{/if}\n\n\t\t{#if showCompass}\n\t\t\t<div\n\t\t\t\tclass=\"border-border bg-background flex flex-col overflow-hidden rounded-md border shadow-sm\"\n\t\t\t>\n\t\t\t\t<button\n\t\t\t\t\tonclick={handleResetBearing}\n\t\t\t\t\taria-label=\"Reset bearing to north\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclass=\"hover:bg-accent flex size-8 items-center justify-center transition-colors\"\n\t\t\t\t>\n\t\t\t\t\t<svg\n\t\t\t\t\t\tbind:this={compassElement}\n\t\t\t\t\t\tviewBox=\"0 0 24 24\"\n\t\t\t\t\t\tclass=\"size-5 transition-transform duration-200\"\n\t\t\t\t\t\tstyle=\"transform-style: preserve-3d;\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<path d=\"M12 2L16 12H12V2Z\" class=\"fill-red-500\" />\n\t\t\t\t\t\t<path d=\"M12 2L8 12H12V2Z\" class=\"fill-red-300\" />\n\t\t\t\t\t\t<path d=\"M12 22L16 12H12V22Z\" class=\"fill-muted-foreground/60\" />\n\t\t\t\t\t\t<path d=\"M12 22L8 12H12V22Z\" class=\"fill-muted-foreground/30\" />\n\t\t\t\t\t</svg>\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t{/if}\n\n\t\t{#if showLocate}\n\t\t\t<div\n\t\t\t\tclass=\"border-border bg-background flex flex-col overflow-hidden rounded-md border shadow-sm\"\n\t\t\t>\n\t\t\t\t<button\n\t\t\t\t\tonclick={handleLocate}\n\t\t\t\t\taria-label=\"Find my location\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\"hover:bg-accent dark:hover:bg-accent/40 flex size-8 items-center justify-center transition-colors\",\n\t\t\t\t\t\twaitingForLocation && \"pointer-events-none cursor-not-allowed opacity-50\"\n\t\t\t\t\t)}\n\t\t\t\t\tdisabled={waitingForLocation}\n\t\t\t\t>\n\t\t\t\t\t{#if waitingForLocation}\n\t\t\t\t\t\t<Loader2 class=\"size-4 animate-spin\" />\n\t\t\t\t\t{:else}\n\t\t\t\t\t\t<Locate class=\"size-4\" />\n\t\t\t\t\t{/if}\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t{/if}\n\n\t\t{#if showFullscreen}\n\t\t\t<div\n\t\t\t\tclass=\"border-border bg-background flex flex-col overflow-hidden rounded-md border shadow-sm\"\n\t\t\t>\n\t\t\t\t<button\n\t\t\t\t\tonclick={handleFullscreen}\n\t\t\t\t\taria-label=\"Toggle fullscreen\"\n\t\t\t\t\ttype=\"button\"\n\t\t\t\t\tclass=\"hover:bg-accent dark:hover:bg-accent/40 flex size-8 items-center justify-center transition-colors\"\n\t\t\t\t>\n\t\t\t\t\t<Maximize class=\"size-4\" />\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t{/if}\n\t</div>\n{/if}\n",
			"type": "registry:ui",
			"target": "map/MapControls.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL from \"maplibre-gl\";\n\n\tinterface Props {\n\t\t/** Optional unique identifier for the route layer */\n\t\tid?: string;\n\t\t/** Array of [longitude, latitude] coordinate pairs defining the route */\n\t\tcoordinates: [number, number][];\n\t\t/** Line color as CSS color value (default: \"#4285F4\") */\n\t\tcolor?: string;\n\t\t/** Line width in pixels (default: 3) */\n\t\twidth?: number;\n\t\t/** Line opacity from 0 to 1 (default: 0.8) */\n\t\topacity?: number;\n\t\t/** Dash pattern [dash length, gap length] for dashed lines */\n\t\tdashArray?: [number, number];\n\t\t/** Callback when the route line is clicked */\n\t\tonclick?: () => void;\n\t\t/** Callback when mouse enters the route line */\n\t\tonmouseenter?: () => void;\n\t\t/** Callback when mouse leaves the route line */\n\t\tonmouseleave?: () => void;\n\t\t/** Whether the route is interactive - shows pointer cursor on hover (default: true) */\n\t\tinteractive?: boolean;\n\t}\n\n\tlet {\n\t\tcoordinates,\n\t\tcolor = \"#4285F4\",\n\t\twidth = 3,\n\t\topacity = 0.8,\n\t\tdashArray,\n\t\tonclick,\n\t\tonmouseenter,\n\t\tonmouseleave,\n\t\tinteractive = true,\n\t\tid = crypto.randomUUID(),\n\t}: Props = $props();\n\n\tconst mapCtx = getContext<{\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisStyleReady: () => boolean;\n\t}>(\"map\");\n\n\tconst sourceId = $derived(`route-source-${id}`);\n\tconst layerId = $derived(`route-layer-${id}`);\n\n\t// Add route when map is ready\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map || coordinates.length < 2) return;\n\n\t\t// Remove existing layer and source if they exist\n\t\tif (map.getLayer(layerId)) map.removeLayer(layerId);\n\t\tif (map.getSource(sourceId)) map.removeSource(sourceId);\n\n\t\t// Add source\n\t\tmap.addSource(sourceId, {\n\t\t\ttype: \"geojson\",\n\t\t\tdata: {\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tproperties: {},\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\tcoordinates,\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\n\t\t// Build paint options with transition definitions\n\t\t// Use default values here - they'll be updated by the paint property effect\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tconst paint: any = {\n\t\t\t\"line-color\": \"#94a3b8\", // Start with gray (unselected color)\n\t\t\t\"line-width\": 5, // Start with unselected width\n\t\t\t\"line-opacity\": 0.6, // Start with unselected opacity\n\t\t\t\"line-color-transition\": { duration: 300, delay: 0 },\n\t\t\t\"line-width-transition\": { duration: 300, delay: 0 },\n\t\t\t\"line-opacity-transition\": { duration: 300, delay: 0 },\n\t\t};\n\n\t\tif (dashArray) {\n\t\t\tpaint[\"line-dasharray\"] = dashArray;\n\t\t}\n\n\t\t// Add layer\n\t\tmap.addLayer({\n\t\t\tid: layerId,\n\t\t\ttype: \"line\",\n\t\t\tsource: sourceId,\n\t\t\tlayout: {\n\t\t\t\t\"line-join\": \"round\",\n\t\t\t\t\"line-cap\": \"round\",\n\t\t\t},\n\t\t\tpaint,\n\t\t});\n\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tif (map.getLayer(layerId)) map.removeLayer(layerId);\n\t\t\t\tif (map.getSource(sourceId)) map.removeSource(sourceId);\n\t\t\t} catch {\n\t\t\t\t// Ignore errors during cleanup\n\t\t\t}\n\t\t};\n\t});\n\n\t// Update route data when coordinates change\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map || coordinates.length < 2) return;\n\n\t\tconst source = map.getSource(sourceId) as MapLibreGL.GeoJSONSource | undefined;\n\t\tif (source) {\n\t\t\tsource.setData({\n\t\t\t\ttype: \"Feature\",\n\t\t\t\tproperties: {},\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: \"LineString\",\n\t\t\t\t\tcoordinates,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t});\n\n\t// Update paint properties when they change\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map || !map.getLayer(layerId)) return;\n\n\t\tmap.setPaintProperty(layerId, \"line-color\", color);\n\t\tmap.setPaintProperty(layerId, \"line-width\", width);\n\t\tmap.setPaintProperty(layerId, \"line-opacity\", opacity);\n\n\t\tif (dashArray) {\n\t\t\tmap.setPaintProperty(layerId, \"line-dasharray\", dashArray);\n\t\t}\n\n\t\t// Move selected routes to top (when opacity is 1, it's selected)\n\t\tif (opacity === 1) {\n\t\t\ttry {\n\t\t\t\tmap.moveLayer(layerId);\n\t\t\t} catch {\n\t\t\t\t// Layer might not exist yet\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle click and hover events\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map || !interactive) return;\n\n\t\tconst handleClick = () => {\n\t\t\tonclick?.();\n\t\t};\n\t\tconst handleMouseEnter = () => {\n\t\t\tmap.getCanvas().style.cursor = \"pointer\";\n\t\t\tonmouseenter?.();\n\t\t};\n\t\tconst handleMouseLeave = () => {\n\t\t\tmap.getCanvas().style.cursor = \"\";\n\t\t\tonmouseleave?.();\n\t\t};\n\n\t\tmap.on(\"click\", layerId, handleClick);\n\t\tmap.on(\"mouseenter\", layerId, handleMouseEnter);\n\t\tmap.on(\"mouseleave\", layerId, handleMouseLeave);\n\n\t\treturn () => {\n\t\t\tmap.off(\"click\", layerId, handleClick);\n\t\t\tmap.off(\"mouseenter\", layerId, handleMouseEnter);\n\t\t\tmap.off(\"mouseleave\", layerId, handleMouseLeave);\n\t\t};\n\t});\n</script>\n",
			"type": "registry:ui",
			"target": "map/MapRoute.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"P extends GeoJSON.GeoJsonProperties\">\n\timport { getContext } from \"svelte\";\n\timport MapLibreGL from \"maplibre-gl\";\n\n\tinterface Props {\n\t\t/** GeoJSON FeatureCollection data or URL to fetch GeoJSON from */\n\t\tdata: string | GeoJSON.FeatureCollection<GeoJSON.Point, P>;\n\t\t/** Maximum zoom level to cluster points on (default: 14) */\n\t\tclusterMaxZoom?: number;\n\t\t/** Radius of each cluster when clustering points in pixels (default: 50) */\n\t\tclusterRadius?: number;\n\t\t/** Colors for cluster circles: [small, medium, large] based on point count (default: [\"#22c55e\", \"#eab308\", \"#ef4444\"]) */\n\t\tclusterColors?: [string, string, string];\n\t\t/** Point count thresholds for color/size steps: [medium, large] (default: [100, 750]) */\n\t\tclusterThresholds?: [number, number];\n\t\t/** Color for unclustered individual points (default: \"#3b82f6\") */\n\t\tpointColor?: string;\n\t\t/** Callback when an unclustered point is clicked */\n\t\tonpointclick?: (\n\t\t\tfeature: GeoJSON.Feature<GeoJSON.Point, P>,\n\t\t\tcoordinates: [number, number]\n\t\t) => void;\n\t\t/** Callback when a cluster is clicked. If not provided, zooms into the cluster */\n\t\tonclusterclick?: (clusterId: number, coordinates: [number, number], pointCount: number) => void;\n\t}\n\n\tlet {\n\t\tdata,\n\t\tclusterMaxZoom = 14,\n\t\tclusterRadius = 50,\n\t\tclusterColors = [\"#22c55e\", \"#eab308\", \"#ef4444\"],\n\t\tclusterThresholds = [100, 750],\n\t\tpointColor = \"#3b82f6\",\n\t\tonpointclick,\n\t\tonclusterclick,\n\t}: Props = $props();\n\n\tconst mapCtx = getContext<{\n\t\tgetMap: () => MapLibreGL.Map | null;\n\t\tisStyleReady: () => boolean;\n\t}>(\"map\");\n\n\tconst id = crypto.randomUUID();\n\tconst sourceId = $derived(`cluster-source-${id}`);\n\tconst clusterLayerId = $derived(`clusters-${id}`);\n\tconst clusterCountLayerId = $derived(`cluster-count-${id}`);\n\tconst unclusteredLayerId = $derived(`unclustered-point-${id}`);\n\n\tconst styleProps = $derived({\n\t\tclusterColors,\n\t\tclusterThresholds,\n\t\tpointColor,\n\t});\n\n\t// Add source and layers when map is ready\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map) return;\n\n\t\t// Remove existing layers and source if they exist\n\t\ttry {\n\t\t\tif (map.getLayer(clusterCountLayerId)) map.removeLayer(clusterCountLayerId);\n\t\t\tif (map.getLayer(unclusteredLayerId)) map.removeLayer(unclusteredLayerId);\n\t\t\tif (map.getLayer(clusterLayerId)) map.removeLayer(clusterLayerId);\n\t\t\tif (map.getSource(sourceId)) map.removeSource(sourceId);\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\n\t\t// Add clustered GeoJSON source\n\t\tmap.addSource(sourceId, {\n\t\t\ttype: \"geojson\",\n\t\t\tdata,\n\t\t\tcluster: true,\n\t\t\tclusterMaxZoom,\n\t\t\tclusterRadius,\n\t\t});\n\n\t\t// Add cluster circles layer\n\t\tmap.addLayer({\n\t\t\tid: clusterLayerId,\n\t\t\ttype: \"circle\",\n\t\t\tsource: sourceId,\n\t\t\tfilter: [\"has\", \"point_count\"],\n\t\t\tpaint: {\n\t\t\t\t\"circle-color\": [\n\t\t\t\t\t\"step\",\n\t\t\t\t\t[\"get\", \"point_count\"],\n\t\t\t\t\tclusterColors[0],\n\t\t\t\t\tclusterThresholds[0],\n\t\t\t\t\tclusterColors[1],\n\t\t\t\t\tclusterThresholds[1],\n\t\t\t\t\tclusterColors[2],\n\t\t\t\t],\n\t\t\t\t\"circle-radius\": [\n\t\t\t\t\t\"step\",\n\t\t\t\t\t[\"get\", \"point_count\"],\n\t\t\t\t\t20,\n\t\t\t\t\tclusterThresholds[0],\n\t\t\t\t\t30,\n\t\t\t\t\tclusterThresholds[1],\n\t\t\t\t\t40,\n\t\t\t\t],\n\t\t\t\t\"circle-stroke-width\": 1,\n\t\t\t\t\"circle-stroke-color\": \"#fff\",\n\t\t\t\t\"circle-opacity\": 0.85,\n\t\t\t},\n\t\t});\n\n\t\t// Add cluster count text layer\n\t\tmap.addLayer({\n\t\t\tid: clusterCountLayerId,\n\t\t\ttype: \"symbol\",\n\t\t\tsource: sourceId,\n\t\t\tfilter: [\"has\", \"point_count\"],\n\t\t\tlayout: {\n\t\t\t\t\"text-field\": \"{point_count_abbreviated}\",\n\t\t\t\t\"text-size\": 12,\n\t\t\t},\n\t\t\tpaint: {\n\t\t\t\t\"text-color\": \"#fff\",\n\t\t\t},\n\t\t});\n\n\t\t// Add unclustered point layer\n\t\tmap.addLayer({\n\t\t\tid: unclusteredLayerId,\n\t\t\ttype: \"circle\",\n\t\t\tsource: sourceId,\n\t\t\tfilter: [\"!\", [\"has\", \"point_count\"]],\n\t\t\tpaint: {\n\t\t\t\t\"circle-color\": pointColor,\n\t\t\t\t\"circle-radius\": 5,\n\t\t\t\t\"circle-stroke-width\": 2,\n\t\t\t\t\"circle-stroke-color\": \"#fff\",\n\t\t\t},\n\t\t});\n\n\t\treturn () => {\n\t\t\ttry {\n\t\t\t\tif (map.getLayer(clusterCountLayerId)) map.removeLayer(clusterCountLayerId);\n\t\t\t\tif (map.getLayer(unclusteredLayerId)) map.removeLayer(unclusteredLayerId);\n\t\t\t\tif (map.getLayer(clusterLayerId)) map.removeLayer(clusterLayerId);\n\t\t\t\tif (map.getSource(sourceId)) map.removeSource(sourceId);\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t};\n\t});\n\n\t// Update source data when data prop changes (only for non-URL data)\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map || typeof data === \"string\") return;\n\n\t\tconst source = map.getSource(sourceId) as MapLibreGL.GeoJSONSource | undefined;\n\t\tif (source) {\n\t\t\tsource.setData(data);\n\t\t}\n\t});\n\n\t// Update layer styles when props change\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map) return;\n\n\t\tconst prev = styleProps;\n\t\tconst colorsChanged =\n\t\t\tprev.clusterColors !== clusterColors || prev.clusterThresholds !== clusterThresholds;\n\n\t\t// Update cluster layer colors and sizes\n\t\tif (map.getLayer(clusterLayerId) && colorsChanged) {\n\t\t\tmap.setPaintProperty(clusterLayerId, \"circle-color\", [\n\t\t\t\t\"step\",\n\t\t\t\t[\"get\", \"point_count\"],\n\t\t\t\tclusterColors[0],\n\t\t\t\tclusterThresholds[0],\n\t\t\t\tclusterColors[1],\n\t\t\t\tclusterThresholds[1],\n\t\t\t\tclusterColors[2],\n\t\t\t]);\n\t\t\tmap.setPaintProperty(clusterLayerId, \"circle-radius\", [\n\t\t\t\t\"step\",\n\t\t\t\t[\"get\", \"point_count\"],\n\t\t\t\t20,\n\t\t\t\tclusterThresholds[0],\n\t\t\t\t30,\n\t\t\t\tclusterThresholds[1],\n\t\t\t\t40,\n\t\t\t]);\n\t\t}\n\n\t\t// Update unclustered point layer color\n\t\tif (map.getLayer(unclusteredLayerId) && prev.pointColor !== pointColor) {\n\t\t\tmap.setPaintProperty(unclusteredLayerId, \"circle-color\", pointColor);\n\t\t}\n\t});\n\n\t// Handle click events\n\t$effect(() => {\n\t\tconst map = mapCtx.getMap();\n\t\tconst loaded = mapCtx.isStyleReady();\n\n\t\tif (!loaded || !map) return;\n\n\t\t// Cluster click handler - zoom into cluster\n\t\tconst handleClusterClick = async (\n\t\t\te: MapLibreGL.MapMouseEvent & {\n\t\t\t\tfeatures?: MapLibreGL.MapGeoJSONFeature[];\n\t\t\t}\n\t\t) => {\n\t\t\tconst features = map.queryRenderedFeatures(e.point, {\n\t\t\t\tlayers: [clusterLayerId],\n\t\t\t});\n\t\t\tif (!features.length) return;\n\n\t\t\tconst feature = features[0];\n\t\t\tconst clusterId = feature.properties?.cluster_id as number;\n\t\t\tconst pointCount = feature.properties?.point_count as number;\n\t\t\tconst coordinates = (feature.geometry as GeoJSON.Point).coordinates as [number, number];\n\n\t\t\tif (onclusterclick) {\n\t\t\t\tonclusterclick(clusterId, coordinates, pointCount);\n\t\t\t} else {\n\t\t\t\t// Default behavior: zoom to cluster expansion zoom\n\t\t\t\tconst source = map.getSource(sourceId) as MapLibreGL.GeoJSONSource;\n\t\t\t\tconst zoom = await source.getClusterExpansionZoom(clusterId);\n\t\t\t\tmap.easeTo({\n\t\t\t\t\tcenter: coordinates,\n\t\t\t\t\tzoom,\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Unclustered point click handler\n\t\tconst handlePointClick = (\n\t\t\te: MapLibreGL.MapMouseEvent & {\n\t\t\t\tfeatures?: MapLibreGL.MapGeoJSONFeature[];\n\t\t\t}\n\t\t) => {\n\t\t\tif (!onpointclick || !e.features?.length) return;\n\n\t\t\tconst feature = e.features[0];\n\t\t\tconst coordinates = (feature.geometry as GeoJSON.Point).coordinates.slice() as [\n\t\t\t\tnumber,\n\t\t\t\tnumber,\n\t\t\t];\n\n\t\t\t// Handle world copies\n\t\t\twhile (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n\t\t\t\tcoordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n\t\t\t}\n\n\t\t\tonpointclick(feature as unknown as GeoJSON.Feature<GeoJSON.Point, P>, coordinates);\n\t\t};\n\n\t\t// Cursor style handlers\n\t\tconst handleMouseEnterCluster = () => {\n\t\t\tmap.getCanvas().style.cursor = \"pointer\";\n\t\t};\n\t\tconst handleMouseLeaveCluster = () => {\n\t\t\tmap.getCanvas().style.cursor = \"\";\n\t\t};\n\t\tconst handleMouseEnterPoint = () => {\n\t\t\tif (onpointclick) {\n\t\t\t\tmap.getCanvas().style.cursor = \"pointer\";\n\t\t\t}\n\t\t};\n\t\tconst handleMouseLeavePoint = () => {\n\t\t\tmap.getCanvas().style.cursor = \"\";\n\t\t};\n\n\t\tmap.on(\"click\", clusterLayerId, handleClusterClick);\n\t\tmap.on(\"click\", unclusteredLayerId, handlePointClick);\n\t\tmap.on(\"mouseenter\", clusterLayerId, handleMouseEnterCluster);\n\t\tmap.on(\"mouseleave\", clusterLayerId, handleMouseLeaveCluster);\n\t\tmap.on(\"mouseenter\", unclusteredLayerId, handleMouseEnterPoint);\n\t\tmap.on(\"mouseleave\", unclusteredLayerId, handleMouseLeavePoint);\n\n\t\treturn () => {\n\t\t\tmap.off(\"click\", clusterLayerId, handleClusterClick);\n\t\t\tmap.off(\"click\", unclusteredLayerId, handlePointClick);\n\t\t\tmap.off(\"mouseenter\", clusterLayerId, handleMouseEnterCluster);\n\t\t\tmap.off(\"mouseleave\", clusterLayerId, handleMouseLeaveCluster);\n\t\t\tmap.off(\"mouseenter\", unclusteredLayerId, handleMouseEnterPoint);\n\t\t\tmap.off(\"mouseleave\", unclusteredLayerId, handleMouseLeavePoint);\n\t\t};\n\t});\n</script>\n",
			"type": "registry:ui",
			"target": "map/MapClusterLayer.svelte"
		},
		{
			"content": "export { default as Map } from \"./Map.svelte\";\nexport type { MapViewport } from \"./Map.svelte\";\nexport { default as MapMarker } from \"./MapMarker.svelte\";\nexport { default as MarkerContent } from \"./MarkerContent.svelte\";\nexport { default as MarkerPopup } from \"./MarkerPopup.svelte\";\nexport { default as MarkerTooltip } from \"./MarkerTooltip.svelte\";\nexport { default as MarkerLabel } from \"./MarkerLabel.svelte\";\nexport { default as MapControls } from \"./MapControls.svelte\";\nexport { default as MapPopup } from \"./MapPopup.svelte\";\nexport { default as MapRoute } from \"./MapRoute.svelte\";\nexport { default as MapClusterLayer } from \"./MapClusterLayer.svelte\";\n",
			"type": "registry:ui",
			"target": "map/index.ts"
		}
	]
}
